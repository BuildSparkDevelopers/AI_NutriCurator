# 🎤 AI-NutriCurator 발표 대본
**Team BuildSparkDevelopers | 목표 발표 시간: 약 10분**

---

## 📌 [슬라이드 1] 타이틀 — AI_NutriCurator
⏱ 예상 소요: 약 40초

> 안녕하세요. 저희는 팀 **BuildSparkDevelopers**입니다.
>
> 오늘 발표드릴 프로젝트는 **AI_NutriCurator**입니다.
> **'만성질환 환자에게 안전한 결정을 지원하는 AI 식품 추천 '** 입니다.

---

## 📌 [슬라이드 2] 문제 정의 — 정보 비대칭과 선택의 어려움
⏱ 예상 소요: 약 1분 20초


> 당뇨, 고혈압, 신장질환 같은 만성질환을 가진 환자들은 마트나 온라인 쇼핑몰에서 식품을 고를 때마다 "이거 먹어도 될까?"라는 질문을 반복합니다. 이 문제의 원인은 크게 다섯 가지입니다.
>
> 첫째, **라벨 판독의 번거로움**입니다. 식약처에서 식품표시를 의무화하고 있으나 환자가 성분표를 자신의 상황에 맞게 판단하기는 번거롭습니다.
>
> 둘째, **질환별 맞춤 필터의 부재**입니다. 기존 커머스는 일반 소비자를 대상으로 하므로, 필터링 기능이 질환자에게는 부적합할 수 있습니다.
>
> 셋째, **불완전한 안전성 정보**입니다. 실제 필요한 정보가 불명확하거나 부재하여 환자 스스로 안전성을 확신하기 어렵습니다.
>
> 넷째, **개인화된 임계값의 실시간 반영 한계**입니다. 나트륨이나 당류 같은 개인별 섭취 제한량을 쇼핑 중 실시간으로 계산하는 건 사실상 불가능합니다.
>
> 이 모든 것이 합쳐져, 결국 **구매 지연과 건강 리스크 증가**라는 결과로 이어집니다. 저희는 바로 이 구조적인 문제를 해결하고자 했습니다.

---

## 📌 [슬라이드 3] 솔루션 — 신뢰 기반 DB + 다중 에이전트 AI
⏱ 예상 소요: 약 1분

> 저희의 솔루션은 **공신력 있는 데이터베이스**와 **다중 에이전트 AI**의 결합입니다.
>
> 네 가지 핵심 가치를 중심으로 설계했습니다.
>
> **DATA** — 식약처 고시 및 신뢰도 높은 출처 기반의 DB와 --질환 가이드라인 RAG를 결합하여-- 정보의 정확도를 높였습니다.
>
> **LOGIC** — User, Chat, Reco, SubReco, Response 에이전트가 오케스트레이션을 통해 체계적으로 분석하고 추천하는 다중 에이전트 구조입니다.
>
> **SPEED** — AI분석 버튼을 누르면 제품명과 원재료를 기반으로 즉시 PASS / WARN 판정을 제공합니다.
>
> **SAFETY** — '왜 위험한지'에 대한 리포트와 함께 안전한 대체 식품을 제안합니다.
>
> 기존의 불확실하고 피로도 높은 선택 과정을, AI가 신뢰할 수 있는 방식으로 대체하는 것을 목표로 합니다.

---

## 📌 [슬라이드 4] 주요 기능 Top 5
⏱ 예상 소요: 약 1분

> 주요 요소 다섯 가지를 소개드리겠습니다.
>
> **01. 사용자 프로필 관리** — 알레르기 정보와 당뇨, 고혈압 등 질환별 섭취 제한사항을 정밀하게 설정하고 관리합니다.
>
> **02. 제품 알레르기 분석** — 식약처 고시 22종 알레르기 유발 물질을 기준으로 원재료를 정밀 분석하여 잠재적 위험 요소를 식별합니다.
>
> **03. 대체재 추천** — 특정 성분으로 인해 섭취가 불가능한 경우, 유사한 맛과 영양을 가진 안전한 대체 제품을 AI가 제안합니다.
>
> **04. 실시간 분석** — 버튼 하나로 빠르게 분석 결과를 제공합니다.
>
> **05. 안전성 평가 리포트** — 단순한 O/X가 아닌, PASS / WARN / SAFE 판정과 함께 위반 근거가 담긴 상세 리포트를 발행합니다.

---

## 📌 [슬라이드 5] 프로젝트 구조
⏱ 예상 소요: 약 40초

> 프로젝트는 체계적인 모듈 분리를 통해 확장성과 유지보수성을 확보했습니다.
>
> **ai/** 폴더에는 LangGraph 기반의 에이전트 오케스트레이션 로직이 위치합니다. 핵심 AI 판단 로직을 담당합니다.
>
> **app/ & api/** 는 FastAPI 기반 서버와 API 엔드포인트를 정의하며, Pydantic을 통한 데이터 검증을 포함합니다.
>
> **frontend/** 는 Next.js와 Tailwind CSS로 스타일링된 반응형 UI를 제공합니다.
>
> 이 구조를 통해 각 역할이 명확히 분리되어, 이후 기능 확장 시에도 안정적으로 개발할 수 있습니다.

---

## 📌 [슬라이드 6] 시스템 아키텍처
⏱ 예상 소요: 약 40초

> 전체 시스템 아키텍처를 간략히 설명드리겠습니다.
>
> 사용자가 Next.js 프론트엔드에서 [AI분석] 버튼을 눌러 이벤트를 발생시키면, HTTP/REST를 통해 **FastAPI 백엔드**로 요청이 전달됩니다.
>
> 백엔드는 내부적으로 **LangGraph 기반의 AI 오케스트레이션** 레이어를 호출하며, 여기서 Orch-01, User-01, Chat-01, Reco-01, sub-Reco-01 네 개의 에이전트가 로직에 따라 작동합니다.
>
> 각 에이전트는 사용자 건강 프로필 DB, 제품 영양 정보 DB, 의료 가이드라인 Rules를 참조하여 최종 판정을 도출합니다.

---

## 📌 [슬라이드 7] 다중 에이전트 플로우 (LangGraph Orchestration)
⏱ 예상 소요: 약 50초

> 이제 에이전트가 실제로 어떻게 작동하는지, 전체 플로우를 보여드리겠습니다.
>
> 사용자가 장바구니에 담기를 누르는 순간 START가 됩니다.
>
> **Node 1 (Orch-01)** 에서 질환 보유 여부를 1차 확인합니다. 질환이 없으면 바로 PASS로 종료, 있으면 다음 노드로 이동합니다.
>
> **Node 2 (User-01)** 에서 사용자 건강 프로필을 조회하고, 우선순위 맵에 따라 통합 프로필 JSON을 생성합니다.
>
> **Node 3 (Chat-01)** 에서 제품 성분과 질환 가이드라인을 대조해 PASS 또는 WARN을 판정합니다.
>
> WARN이 발생하면 **Node 4 (Reco-01)** 로 넘어가 유사 상품을 검색하고 최종 추천 결과를 반환합니다.
>
> **Node 5 (SubReco-01)** 에서 Reco-01의 추천 상품을 scoring하여 최종 추천 결과를 반환합니다.

---

## 📌 [슬라이드 8] Node 01 — Orch-01 적격성 확인 및 라우팅
⏱ 예상 소요: 약 40초

> 첫 번째 노드인 **Orch-01**은 라우팅 역할을 합니다.
>
> 두 가지 조건을 순서대로 체크합니다.
> 먼저 사용자가 당뇨, 고혈압, 신장질환, 알레르기 중 하나라도 보유하고 있는지 확인합니다. 질환이 없다면 즉시 종료입니다.
>
> 질환이 있다면, 해당 식품에 질환 유관 성분이 포함되어 있는지를 추가로 확인합니다. 유관 성분이 없다면 역시 PASS로 종료, 성분이 감지되면 Chat과 Reco 에이전트로 분기됩니다.
>
> 이 노드가 불필요한 분석을 사전에 차단하여 전체 시스템의 효율을 높여줍니다.

---

## 📌 [슬라이드 9] Node 02 — User-01 프로필 조회 및 우선순위 병합
⏱ 예상 소요: 약 40초

> 두 번째 노드인 **User-01**은 사용자의 건강 프로필을 조회하고 병합합니다.
>
> 복수의 질환이 있을 경우, 우선순위 맵에 따라 충돌하는 규칙을 해결합니다. 우선순위는 알레르기 → 신장질환 → 당뇨 → 고혈압 순입니다.
>
> 임계값 기반 필터링과 문자열 기반 알레르겐 필터링을 병합하여, 최종적으로 해당 사용자에게 최적화된 **Final Profile JSON**을 출력합니다.
> 예를 들어 나트륨 2,000mg 미만, 당류 5g 미만, 알레르겐 땅콩 배제 같은 조건이 하나의 프로필로 통합됩니다.

---

## 📌 [슬라이드 10] Node 03 — Chat-01 근거 생성 및 적합성 판별
⏱ 예상 소요: 약 40초

> 세 번째 노드인 **Chat-01**은 근거 기반 분석을 수행합니다.
>
> Final Profile에서 질환별 임계값을 불러오고, 제품의 영양 성분 수치와 직접 대조합니다.
>
> 예를 들어, 나트륨이 700mg으로 제한치 약 667mg를 초과하거나, 당류가 10g으로 기준 5g를 넘긴 경우 해당 영양소는 위반으로 기록됩니다.
>
> 위반 항목이 하나라도 발생하면 **WARN** 판정과 함께 위반 영양소 리스트, 실제값과 기준값을 담은 상세 Evidence JSON을 생성하여 다음 노드로 전달합니다.

---

## 📌 [슬라이드 11] Node 04 — Reco-01 추천 로직 (Index 기반 Top-K)
⏱ 예상 소요: 약 55초

> **Reco-01**은 WARN 판정이 난 경우 안전한 대체 상품을 추천하는 노드입니다.
>
> 먼저 **Index Build** 단계에서, 모든 상품의 이름·브랜드·원재료·카테고리를 하나의 `index_text`로 미리 합쳐 `final_db`에 캐싱해 둡니다. 과자·디저트류는 맛 키워드를 `taste:tag` 형태로 추가 태깅합니다.
>
> **Retrieve & Rank** 단계에서는 후보군을 같은 카테고리, 이웃 카테고리, 폴백의 세 버킷으로 분류하고, 각 버킷 안에서 맛 태그 겹침인 `taste_score`와 재료 겹침인 `token_overlap` 순으로 정렬합니다.
>
> **Final Output** 단계에서는 버킷별 가중치 60/30/10% 비율로 Top-K 상품을 선발하고, 후보가 부족하면 다음 버킷에서 자동으로 채워 항상 K개를 보장합니다.
> 선발된 후보는 바로 다음 Sub-Reco-01로 넘어가 2차 검증을 받게 됩니다.

---

## 📌 [슬라이드 12] Node 04-1 — Sub-Reco-01 질병별 건강 점수 계산
⏱ 예상 소요: 약 45초

> Sub-Reco-01은 Reco-01이 추려낸 후보 상품들에 대해 **질병별 건강 점수를 산정**하여 최종 추천 순위를 결정하는 서브 에이전트입니다.
>
> 동작은 세 단계로 이루어집니다.
>
> **1단계: 질병 플래그 추출** — 사용자 프로필에서 당뇨, 고혈압, 신장질환 플래그를 확인합니다.
>
> **2단계: 성분 매핑 및 Scoring** — ColumnMapper가 한글 DB 컬럼을 영어 변수로 변환한 뒤, DiseaseScoring 모듈이 점수를 산정합니다. 점수 계산에는 **Michaelis-Menten 곡선**과 나트륨/칼륨 비율, 신장 단계별 **Hill 방정식**을 적용하여 의학적 근거 기반의 정밀한 점수를 도출합니다.
>
> **3단계: 추천 생성 및 정렬** — 각 질병에 대해 0~100점 점수를 계산하고 높은 점수 순으로 내림차순 정렬하여, 사용자에게 가장 적합한 대체 상품을 최종 반환합니다.

---

## 📌 [슬라이드 13] 질병별 영양소 임계값 (Thresholds)
⏱ 예상 소요: 약 35초

> 앞서 설명드린 Chat-01과 Sub-Reco-01의 판별 기준이 되는 임계값을 보여드리겠습니다. 모두 KDA(대한당뇨병학회) 및 KSN(대한신장학회) 가이드라인 기반입니다.
>
> 당뇨는 당류 5g 미만, 식이섬유 1,000kcal당 14g 이상. 고혈압은 나트륨 2,300mg 미만, 총 지방 칼로리의 25% 미만.
> 신장질환 비투석은 단백질 0.55~0.60g/kg, 나트륨 2.3g 미만. 투석 단계는 단백질을 1.0~1.2g으로 늘리고, 칼륨은 2,000mg 미만으로 제한합니다.
>
> 이 수치들이 저희 시스템 전반의 개인화 필터 핵심 데이터로 작동합니다.

---

## 📌 [슬라이드 14] 기술 스택
⏱ 예상 소요: 약 25초

> 기술 스택을 간략히 정리해 드리겠습니다.
>
> 프론트엔드는 Next.js와 Tailwind CSS, 백엔드는 FastAPI와 Uvicorn, AI/ML은 LangGraph 에이전트 오케스트레이션에 Qwen2.5 LLM을 적용했습니다.
> DB는 현재 인메모리이며 향후 Vector DB와 PostgreSQL로 전환 예정이고, 인프라는 Docker와 HTTPS 보안을 갖추고 있습니다.

---

## 📌 [슬라이드 15] API 엔드포인트 및 사용 흐름
⏱ 예상 소요: 약 25초

> API는 제품 조회, 프로필 조회, 분석 요청의 세 엔드포인트로 구성됩니다. 분석 요청은 product_id와 profile_id를 POST로 전달하면 됩니다.
>
> 사용자 흐름은 프로필 선택 → 제품 검색 → AI 분석 요청 → 결과 확인, 총 4단계로 직관적으로 구성되어 있습니다.

---

## 📌 [슬라이드 16] 향후 개발 계획 — Roadmap
⏱ 예상 소요: 약 25초

> 향후 개발은 4개 페이즈로 계획하고 있습니다.
> Phase 1은 계정 인증·DB 연동, Phase 2는 Qwen2.5 LLM 통합·바코드 스캔,
> Phase 3은 심층 영양 리포트·맞춤 식단 추천 고도화, Phase 4는 모바일 앱 출시입니다.

---

## 📌 [슬라이드 17] Team & Legal — 마무리
⏱ 예상 소요: 약 30초

> 마지막으로 한 가지를 꼭 말씀드리고 싶습니다.
>
> AI_NutriCurator는 어디까지나 **보조 도구**입니다.
> 심각한 알레르기가 있거나 기저질환 관리가 필요한 경우, 반드시 전문의와 상담 후 섭취를 결정하셔야 합니다.
>
> 그럼에도 저희가 이 서비스를 만든 이유는, 매일 반복되는 그 불안한 장바구니 앞에서 AI가 조금 더 든든한 동반자가 되어드리고 싶었기 때문입니다.
> 이상으로 AI_NutriCurator 발표를 마치겠습니다. 감사합니다.

---

## 🕐 시간 배분 요약

| 슬라이드 | 내용 | 시간 |
|---------|------|------|
| 1 | 타이틀 / 팀 소개 | 40초 |
| 2 | 문제 정의 | 1분 20초 |
| 3 | 솔루션 개요 | 1분 |
| 4 | 주요 기능 Top 5 | 1분 |
| 5 | 프로젝트 구조 | 40초 |
| 6 | 시스템 아키텍처 | 40초 |
| 7 | 다중 에이전트 플로우 | 50초 |
| 8 | Node 01 Orch-01 | 40초 |
| 9 | Node 02 User-01 | 40초 |
| 10 | Node 03 Chat-01 | 40초 |
| 11 | Node 04 Reco-01 (Index 추천) | 55초 |
| 12 | Node 04-1 Sub-Reco-01 (점수 산정) | 45초 |
| 13 | 질병별 임계값 | 35초 |
| 14 | 기술 스택 | 25초 |
| 15 | API 및 사용 흐름 | 25초 |
| 16 | 로드맵 | 25초 |
| 17 | 마무리 | 30초 |
| **합계** | | **약 10분 00초** |

---
> 💡 **발표 팁**
> - 슬라이드 7(에이전트 플로우 다이어그램)에서 화면을 직접 가리키며 흐름을 설명하면 전달력이 높아집니다.
> - 슬라이드 8~12는 기술 설명이 집중되는 구간입니다. 청중 반응을 보며 속도를 조절하세요.
> - 슬라이드 11→12 전환 시 "Reco-01이 후보를 추리면, Sub-Reco-01이 점수를 매깁니다"라고 한 문장으로 자연스럽게 연결하세요.
> - 슬라이드 13(임계값)은 "이 수치들이 바로 앞 두 노드의 판별 기준으로 사용됩니다"라고 앞 슬라이드와 연결해 주세요.